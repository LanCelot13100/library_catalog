1. core/base_api_client.py - выполняет функцию предоставления абстрактного каркаса для работы со всеми остальными API-клиентами (JsonBin, OpenLibrary). 
    - __init__
      - Сохраняет базовый URL сервиса + создает HTTP-сессию
      - Добавляет заголовки в Headers, если они вообще есть
    - _request
      - Представляет универсальный метод для отправки HTTP-запросов, который формирует полный URL и отправляет запрос через requests
      - Логирует сам запрос, его успешные ответы, а также ошибки
      - Возвращает готовый json()
    - Абстрактные методы
      - Гарантирует единый интерфейс среди клиентов
2. core/exceptions.py - хранит собственные исключения
   - Выбрасывается, если случается ошибка при HTTP-запросе
3. clients/jsonbin_client.py - работает с JsonBin.io (хранилищем книг)
   - Наследуется от класса BaseApiClient
   - В __init__ берет JSONBIN_API_KEY и BIN_ID и формирует заголовки, вызывая super() в конце с base_url и headers
   - Метод get() читает текущее содержимое бина (все книги)
   - Метод put(payload) обновляет бин (перезаписывает весь список книг)
   - Метод post() не реализован (JsonBin работает без POST)
4. clients/openlibrary_client.py - работает с OpenLibrary API (библиотека, откуда мы берем описание и т.д.)
   - В классе OpenLibrary(BaseApiClient):
     - В __init__ передает базовый URL
     - Метод get(...) выполняет GET-запрос
     - Метод search book(...) делает GET /search.json с параметрами, берет первую найденную книгу (docs[0]) и возвращает словарь с ключами id, title, author, year и т.д.
     - Метод get_book_details(...) запрашивает /works/{id}/json и возвращает описание
5. repositories/book_repository.py - реализовывает CRUD-операции с книгами и интеграцию с OpenLibrary
   - класс BookRepository создает JsonBinClient для работы с БД и создает OpenLibraryClient для поиска информации о книгах
     - get_books(...) делает запрос в JsonBin и возвращает список книг (record)
     - get_books(...,book_id) загружает все книги и ищет книгу по id, возвращая найденную или None
     - add_book(...,book_data) получает список книг, генерирует новый id, ищет в OpenLibrary по названия-автору, добавляет книгу в список, делает PUT в JsonBin и возвращает добавленную книгу
     - update_book(...) загружает список книг, ищет книгу по id, обновляет только переданные поля, сохраняет в JsonBin и возвращает обновленную книгу.
     - delete_book(...) загружает список книг, убирает книгу с данным id, если книга не найдена - None, если найдена - PUT в JsonBin и возврат подтверждения
6. models.py - описывает структуру данных (модели Pydantic)
    - класс Book, который наследуется от BaseModel
      - Поля id, title, author, year_of_releasing, genre, amount_of_pages, status
      - Опциональные поля cover_url, description, subjects
    - класс BookCreate, который наследуется от BaseModel
      - Используется при добавлении книги POST
      - Те же поля, но без id и без OpenLibrary-дополнений
    - класс BookUpdate, который наследуется от BaseModel
      - Используется при обновлении книги PUT
      - Все поля опциональные (Optional)
      - Это значит, что вообще можно менять только 1-2 параметра, а не весь объект
7. main.py - поднимает FastAPI-сервер и связать все вместе
    - repo = BookRepository() инициализирует репозиторий (подключение к JsonBin и OpenLibrary)
    - @app.get("/books") возвращает список книг, где есть фильтры title, author, status
    - @app.get("/books/{book_id}") возвращает книгу по ID, если нет - ошибка 404
    - @app.post("/books") создает книгу, сохраняет в JsonBin, автоматически подтягивает инфу из OpenLibrary
    - @app.put("/books/{book_id}") обновляет книгу по ID. Если книга не найдена - 404
    - @app.delete("/books/{book_id}") удаляет книгу по ID. Если книга не найдена - 404
8. .env - хранит секретную инфу
9. requirements.txt - хранит список библиотек
   - fastapi
   - uvicorn
   - requests
   - python-dotenv
   - pydantic




    
Рассуждения на темы:

Хранение данных в оперативной памяти (ОЗУ) как правило связано с рядом проблем и ограничений, которые нужно понимать при разработке программного обеспечения. Из этих нюансов можно выделить:
- Временный характер данных — Оперативная память является энергозависимой, что значит, что при отключении питания все данные, хранящиеся в ОЗУ, теряются. 
- Ограниченный объём — Если приложению нужно хранить слишком много данных в оперативной памяти, то система может в один момент может дать сбой. 
- Фрагментация памяти — При частом выделении и освобождении памяти образуются «дыры», то есть фрагменты свободной памяти разного размера, что может привести к ситуации, когда есть достаточно свободной памяти в целом, но нет непрерывного блока нужного размера.
- Скорость доступа и конкуренция — Доступ к оперативной памяти быстрый, но не мгновенный. То есть, при работе многопоточных приложений возможны конфликты доступа, когда несколько потоков пытаются одновременно читать/записывать одни и те же данные. 


Можно также хранить данные в файлах. Из преимуществ такого хранения можно выделить:
- Долговременное хранение — данные сохраняются на дисках, флешках или других носителей и не теряются при отключении питания (в отличие от оперативной памяти).
- Простота использования — работа с файлами поддерживается почти всеми языками программирования.
- Переносимость — файлы можно копировать, передавать между системами, архивировать, а также делать резервные копии.
- Независимость от приложений — файлы можно открыть или обработать разными программами.
Из недостатков же данного типа хранения в первую очередь можно выделить:
- Сложность структурирования данных — большие объёмы данных трудно организовать и искать. В любом случае для этого нужны будут индексы. 
- Низкая скорость доступа — поиск конкретной информации в большом файле медленнее, чем в базе данных, особенно при частых операциях чтения и записи
- Ограниченные возможности параллельного доступа — одновременно работать с файлом могут только определённые процессы. Для предотвращения конфликтов требуется блокировка файлов, что снижает производительность.
- Масштабирование — при росте объёма данных и количества пользователей файлы становятся неудобными для управления, из-за чего становиться сложным делать сложные выборки или фильтрацию. 


Если делать сравнительный анализ основных способов хранения данных с точки зрения скорости, долговечности и масштабируемости, то вот как можно сделать следующие выводы:
- RAM — используется для скорости и временных вычислений.
- Файлы — используются для простоты и переносимости, но следует понимать, что в них ограничена структурированность.
- SQL — используется для надёжности, где нужен ACID. 
- NoSQL — используеля в основном из-за гибкости, но слабее контроль целостности.
- Облако — используется из-за доступность и резервирование, но  присутствует прямая зависимость от сети, но иногда не очень удобно. 
- Кэш — используется для ускорения доступа, но сохранениет как правило временные данные.


В самих же файлах может возникать конкурентный доступ к данным, когда несколько процессов или потоков одновременно пытаются читать или изменять одни и те же данные. Если не управлять этим процессом, могут возникнуть некоторые проблемы, такие как:
- Гонки данных (race condition) — когда результат работы программы зависит от порядка выполнения потоков. 
- Потеря обновлений (lost update) — когда два процесса читают одни и те же данные, затем оба вносят изменения и сохраняют результат (последнее сохранение перезаписывает изменения другого потока, и часть данных может потеряться). 
- Грязное чтение (dirty read) — когда один поток читает данные, которые другой поток ещё не закончил изменять (приложение может использовать некорректные или временные значения). 
- Неповторяющееся чтение (non-repeatable read) — когда в процессе выполнения транзакции один поток читает данные дважды. Между этими чтениями другой поток изменяет их (один и тот же запрос возвращает разные результаты, что может нарушать логику программы).
- Фантомные чтения (phantom reads) — когда поток выполняет запрос и пока он работает, другой поток добавляет новые записи, подходящие под условие (при повторном выполнении запроса первый поток получает новые “фантомные” строки, которых не было раньше). 
- Взаимоблокировки (deadlocks) — когда два процесса ждут ресурсы, занятые друг другом, и зависают навсегда, вместе с чем зависает и сама программа.
    